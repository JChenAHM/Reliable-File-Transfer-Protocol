#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <netdb.h>
#include <sys/socket.h>
#include <time.h>
#include <sys/time.h>
#include <unistd.h>     /* for pause */
#include <signal.h>     /* for signal */
#include "packet.h"

/* using queue to handle the sequence of each timeout */
typedef struct {
        int first;                      /* position of first element */
        int last;                       /* position of last element */
        int count;                      /* number of queue elements */
	int q[100];			/* the body of queue */
} queue;
#include "queue.h"


struct alarm_time{
int is_set;
int tv_sec;
int tv_usec;
int duration;
};
struct alarm_time alarm_list[PCK_ROUND*2];
#include "alarm.h"


void handle_alarm();

/* using queue to handle the sequence of each timeout */
queue* signal_queue;


int la_seq;		/* the least acknowledge sequence number */
int ns_seq;		/* the sequence number to be sent next */


int seq[PCK_ROUND*2];	/* array of sequence number */
int retrans_signal[PCK_ROUND*2];/* array that indicate packet retrasmission */
char* retrans_buffer[PCK_ROUND*2];/* buffer that hold the packet to be retransmitted */


int main(int argc, char** argv)
{
	struct sockaddr_in sin; 
	int sock, i, slen=sizeof(sin);
	char buf[BUFLEN];	/* message buffer */
	char *file_buf, *packet;
	int recvlen;		/* # bytes in acknowledgement message */
	int rtt;		/* round trip time in millisecond */
	struct timeval tv;
	struct hostent *host = gethostbyname(argv[1]);
	
	signal_queue = (queue*)malloc(sizeof(queue)); /* initial queue for timeout signal generated by each transmission */

	/* 0: not used
	 * 1: being transmitted, waiting for ack
	 * 2: ack received
	 */
	for(i=0;i<PCK_ROUND*2;i++){
		seq[i] = 0;
	}
	/* 0: no need to retransmission  
	 * 1: need retransmission
	 */
	for(i=0;i<PCK_ROUND*2;i++){
		retrans_signal[i] = 0;
	}

	unsigned int server_addr = *(unsigned int *) host->h_addr_list[0];
	/* server port number */
	unsigned short server_port = atoi (argv[2]);
	
	/* create a socket */

	if ((sock=socket(AF_INET, SOCK_DGRAM, 0))==-1)
		printf("socket created\n");

	/* bind it to the server addresses and use the given port number */
	memset((char *)&sin, 0, sizeof(sin));
	sin.sin_family = AF_INET;
	sin.sin_addr.s_addr = server_addr;
	sin.sin_port = htons(server_port);
	
	FILE *fp = fopen("2.txt", "r");
	/* get the size of the file */
	fseek(fp,0l,SEEK_END);
	int file_size = ftell(fp);
	rewind(fp);
	printf("The file size is %d\n",file_size);
	
	printf("check1 \n"); 
	/* initial packet*/
	packet = (char*)malloc(PCKSIZE*sizeof(char)); 
	gettimeofday(&tv,NULL);
	/* send a ping-pong message to get the rtt */
	*(short *) packet = (short) htons(0); /* 0 means it is a ping packet*/
	*(int *) (packet+2) = (int) htonl(tv.tv_sec);
	*(int *) (packet+6) = (int) htonl(tv.tv_usec);
	*(int *) (packet+10) = (int) htonl(file_size);
	
	printf("sending ping pong packet\n");
	if (sendto(sock, packet, PCKSIZE, 0, (struct sockaddr *)&sin, slen)==-1) {
		perror("ping packet sending failure\n");
		exit(1);
	}

	//free(packet);
	/* now receive a pong packet from the server */
	recvlen = recvfrom(sock, buf, BUFLEN, 0, (struct sockaddr *)&sin, &slen);
        if (recvlen >= 0) {
        	buf[recvlen] = 0;	/* expect a printable string - terminate it */
		int tv_sec, tv_usec;
		tv_sec =  (int)ntohl(*(int *)(buf+2));
		tv_usec = (int)ntohl(*(int *)(buf+6));
		
		gettimeofday(&tv,NULL);
		//printf("tv sec: %d - %d, tv usec %d - %d\n",tv.tv_sec, tv_sec, tv.tv_usec, tv_usec);
        	rtt = 1000000*(tv.tv_sec - tv_sec) + (tv.tv_usec-tv_usec);
		//rtt = 1000000;
	}

	printf("The RTT is %d\n",rtt);
 
	/* read file to a buffer with BUFLEN length and send it to the sever continuously*/	
	packet = (char*)malloc(PCKSIZE*sizeof(char));
	file_buf = (char*)malloc(BUFLEN*sizeof(char));
	if (fp != NULL) {

	    i = 0;
	    la_seq = ns_seq = 0;
	/* send PCK_ROUND number of packets at the first round */ 
	    while(i<PCK_ROUND) {
		file_buf = (char*)malloc(BUFLEN*sizeof(char));
		size_t newLen = fread(file_buf, sizeof(char), BUFLEN, fp);
	    	if (newLen == 0) {
			break;	    	
		}
	    	else {
        		file_buf[++newLen] = '\0'; /* Just to be safe. */
			printf("sending packet with sequence number %d\n",ns_seq);
			//printf("The buffer contains:\n");
			//printf("%s\n\n",file_buf);
			
			/* create the ftp packet */
			*(short *) (packet) = (short) htons(1); /* 1 means it is a ftp packet */
			*(short *) (packet+2) = (short) htons(ns_seq);
			strcpy(packet+4,file_buf);
			int pck_size = 4+newLen;

			if (sendto(sock, packet, pck_size, 0, (struct sockaddr *)&sin, slen) ==-1) {
				perror("buffer sending failure\n");
				exit(1);
			}
			set_alarm(ns_seq,1.5*rtt);
			seq[ns_seq] = 1;
			/* store the buffer for retransmission */
			retrans_buffer[ns_seq] = (char*)malloc(BUFLEN*sizeof(char));
			strcpy(retrans_buffer[ns_seq],file_buf);
			ns_seq = (ns_seq+1)%(PCK_ROUND*2);
			free(file_buf);
    	    	}
		i++;
	    }
	    while(1) {
		
		check_expire(); /* check whether there are alarm expired */
		/*  Keep waiting for acknowledgements from the server */
		/*  Make the recvfrom non blocking to receive latter acknowledgements */
		recvlen = recvfrom(sock, packet, 20, MSG_DONTWAIT, (struct sockaddr *)&sin, &slen);
		//printf("received length is %d\n",recvlen);
                if (recvlen >= 0) {
                        packet[recvlen] = 0;
			short ack_num = (short) ntohs(*(short *)(packet));
			printf("The acknowledge number is %d\n",ack_num);
			seq[ack_num] = 2; /* sequence number is acknowledged */
			
			int count=0;
			if(ack_num == la_seq) { 
				i = la_seq;
				while(seq[i] == 2) {
					seq[i] = 0; /*sliding windows moving right*/
					count++;
					i = (i+1)%(PCK_ROUND*2);

				}
			la_seq = (la_seq+count)%(PCK_ROUND*2);
			}
		/* multiple packets accumulated to be sent */
			while(count != 0) {
				file_buf = (char*)malloc(BUFLEN*sizeof(char));
				size_t newLen = fread(file_buf, sizeof(char), BUFLEN, fp);
	    			if (newLen == 0) {
					break;	    	
				}
	    			else {
		        		file_buf[++newLen] = '\0'; /* Just to be safe. */
					//printf("The buffer contains:\n");
					//printf("%s\n",file_buf);
					printf("sending packet with sequence number %d\n",ns_seq);
					/* create the ftp packet */
					*(short *) (packet) = (short) htons(1); /* 1 means it is a ftp packet */
					*(short *) (packet+2) = (short) htons(ns_seq);
					strcpy(packet+4,file_buf);
					
					int pck_size = 4+newLen;
					if (sendto(sock, packet, pck_size, 0, (struct sockaddr *)&sin, slen) ==-1) {
						perror("buffer sending failure\n");
						exit(1);
					}
					seq[ns_seq] = 1;
					set_alarm(ns_seq,1.5*rtt);
					/* store the buffer for retransmission */
					retrans_buffer[ns_seq] = malloc(BUFLEN*sizeof(char));
					strcpy(retrans_buffer[ns_seq],file_buf);
					ns_seq = (ns_seq+1)%(PCK_ROUND*2);
					count--;
					free(file_buf);
    	    			}
			}
                } // end of transmit new file
		/* check for transmission packets */
		for(i=0;i<PCK_ROUND*2;i++) {			
			if(retrans_signal[i] == 1) {
				retrans_signal[i] = 0;
				/* create the ftp packet */
				packet = (char*)malloc(PCKSIZE*sizeof(char)); 
				*(short *) (packet) = (short) htons(1); /* 1 means it is a ftp packet */
				*(short *) (packet+2) = (short) htons(i);
				strcpy(packet+4,retrans_buffer[i]);
				printf("retransmitting packet with sequence number %d\n",i);
				int pck_size = 4+strlen(retrans_buffer[i]);
				if (sendto(sock, packet, pck_size, 0, (struct sockaddr *)&sin, slen) ==-1) {
					perror("buffer sending failure\n");
					exit(1);
				}
				set_alarm(i,1.5*rtt);
				//seq[i] = 1;
			}
		}		
	    }
	    fclose(fp);
	}

	for (i=0; i < MSGS; i++) {
		sprintf(buf, "This is packet %d", i);
		if (sendto(sock, buf, strlen(buf), 0, (struct sockaddr *)&sin, slen)==-1) {
			perror("sendto");
			exit(1);
		}
		/* now receive an acknowledgement from the server */
		recvlen = recvfrom(sock, buf, BUFLEN, 0, (struct sockaddr *)&sin, &slen);
                if (recvlen >= 0) {
                        buf[recvlen] = 0;	/* expect a printable string - terminate it */
                        printf("received message: \"%s\"\n", buf);
                }
	}
	close(sock);   
	return 0;
}

/* id is the sequence number of a packet and duration is the length of the timeout */
void set_alarm (int id, int duration) {
	struct timeval tv;
 	gettimeofday(&tv,NULL);
 	alarm_list[id].is_set = 1;
 	alarm_list[id].tv_sec = tv.tv_sec;
 	alarm_list[id].tv_usec = tv.tv_usec;
 	alarm_list[id].duration = duration;
}

/* iterate through all the packets being transmitted and check for timeout expires */
void check_expire() {
 	int i;
 	struct timeval tv; 
	/* go through all the possible sequence number */
 	for(i=0;i<PCK_ROUND*2;i++) {
	  if(alarm_list[i].is_set == 1) {	
		gettimeofday(&tv,NULL);
		int elapsed_time = (tv.tv_sec-alarm_list[i].tv_sec)*1000000+(tv.tv_usec - alarm_list[i].tv_usec);
		//printf("elapsed time is %d\n", elapsed_time);
		if( elapsed_time > alarm_list[i].duration) {  
			alarm_list[i].is_set= 0;
	   		handle_alarm(i);
		}
  	   }
 	}
}

void handle_alarm(int seq_num) {
	/* if the acknowledge is not received, perform a retransmission */
	if(seq[seq_num] == 1){
		/* set flag to indicate packet retransmission*/
		retrans_signal[seq_num] = 1;
	}
	printf("handling alarm\n");
}
